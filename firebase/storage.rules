rules_version = '2';

service firebase.storage {
  match /b/{bucket}/o {
  
    // Helpers
    function isAuthenticated() {
      return request.auth != null;
    }
    function isOwner(uid) {
      return request.auth.uid == uid;
    }
    // We can't access firestore easily from storage rules in all tiers, 
    // but we can rely on path structure for basic ownership.
    
    // KYC Images: users/UID/kyc/...
    match /users/{uid}/kyc/{allPaths=**} {
      allow read: if isAuthenticated() && (isOwner(uid) || request.auth.token.role == 'admin'); 
      // Note: request.auth.token.role requires custom claims or blocking functions. 
      // Without that, we can't implement strict 'admin' check in storage easily without a cloud function mirroring claims.
      // Fallback: strictly owner or loose admin if possible, but for MVP standard firebase auth doesn't have role token by default.
      // We will assume for now only OWNER can write. Admin reads might fail if we don't have custom claims.
      // Alternative: allow write if owner. Allow read if owner. Admin logic in storage usually requires custom claims.
      // Let's implement Owner Write / Owner Read.
      allow write: if isOwner(uid);
      allow read: if isOwner(uid);
    }

    // Collateral Images: users/UID/collateral/...
    match /users/{uid}/collateral/{allPaths=**} {
      allow read, write: if isOwner(uid);
    }
    
    // Payment Proofs: users/UID/payments/...
    match /users/{uid}/payments/{allPaths=**} {
      allow read, write: if isOwner(uid);
    }

    // Contracts: users/UID/contracts/...
    match /users/{uid}/contracts/{allPaths=**} {
      allow read: if isOwner(uid);
      allow write: if false; // Only generated by system/admin
    }
    
    // Deny all others
    match /{allPaths=**} {
      allow read, write: if false;
    }
  }
}
